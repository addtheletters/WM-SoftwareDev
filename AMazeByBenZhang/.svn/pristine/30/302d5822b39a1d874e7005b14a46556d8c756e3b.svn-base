package edu.wm.cs.cs301.benzhang.amazebybenzhang;

import android.content.DialogInterface;
import android.content.Intent;
import android.os.Bundle;
import android.os.Handler;
import android.support.design.widget.FloatingActionButton;
import android.support.design.widget.Snackbar;
import android.support.v7.app.AlertDialog;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.widget.Toolbar;
import android.util.Log;
import android.view.View;
import android.widget.TextView;
import android.widget.Toast;

import edu.wm.cs.cs301.benzhang.amazebybenzhang.generation.MazeConfiguration;
import edu.wm.cs.cs301.benzhang.amazebybenzhang.generation.MazeFactory;
import edu.wm.cs.cs301.benzhang.amazebybenzhang.generation.Order;

public class GeneratingActivity extends AppCompatActivity {

    private static final String TAG = "GeneratingActivity";

    private Handler delayer = new Handler();
    private MazeFactory factory;

    private AlertDialog cancelDialog;
    //private int progress = 0;
    //private SimulatedBuildProgress buildTracker;
    //private static final int PROGRESS_UPDATE_DELAY = 50;

//    /**
//     * Represents a MazeController or similar object which will be substituted
//     * holding generated maze information
//     */
//    protected class PlaceholderMaze{
//        int complexity;
//        String builder;
//        public PlaceholderMaze(int complex, String builder){
//            this.complexity = complex;
//            this.builder = builder;
//        }
//    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_generating);
        startGeneration();
    }

    /**
     * Adds dialog requesting confirmation of abort when back button is pressed.
     */
    @Override
    public void onBackPressed() {
        cancelDialog = new AlertDialog.Builder(this)
                .setMessage("Abort loading?")
                .setCancelable(false)
                .setPositiveButton("Yes", new DialogInterface.OnClickListener() {
                    public void onClick(DialogInterface dialog, int id) {
                        delayer.removeCallbacksAndMessages(null); // cancel any simulated operations
                        if(factory != null) {
                            factory.cancel(); // cancel factory if running
                        }
                        GeneratingActivity.this.finish();
                    }
                })
                .setNegativeButton("No", null)
                .create();
        cancelDialog.show();
    }


    /**
     * Starts generation of maze using settings given through the creating intent
     */
    protected void startGeneration(){
        int complexity = getIntentComplexity();
        String generator = getIntentGenerator();
        String driver = getIntentDriver();

        // note: generator or could not matter, if loading maze from a file
        Toast.makeText(this, "Starting load of c:" + complexity + ",g:" + generator + ",d:" + driver, Toast.LENGTH_SHORT).show();

        boolean loadWorked = false;
        if(getIntentLoad()){
            try{
                load();
                loadWorked = true;
            }
            catch(Exception e){
                Toast.makeText(GeneratingActivity.this, "Failed to load from file.", Toast.LENGTH_SHORT).show();
            }
        }

        if(!loadWorked) {
            build();
        }
    }

    /**
     * Simulates creation of a maze occurring over some period of time, with updates to UI
     * @param opVerb verb to simulate using to create the maze
     * @param buildTime time in milliseconds for build to complete
     * @param buildChanges number of updates to make to the GUI during the time taken
     */
    private void simulateBuild(final String opVerb, int buildTime, int buildChanges){
        setLoadingCaption(opVerb + " maze...");
        for(int i = 0; i < buildTime; i+= buildTime / buildChanges){
            delayer.postDelayed(new SimulatedBuildProgress(100 * i / buildTime), i);
        }
        delayer.postDelayed(new Runnable(){
            @Override
            public void run() {
                // simulated 'done'
                setLoadingCaption("Done!");
                Toast.makeText(GeneratingActivity.this, "Finished " + opVerb + ".", Toast.LENGTH_SHORT).show();
                done();
            }
        }, buildTime);
    }

    /**
     * Loads maze from a file.
     */
    private void load(){
        // make this take a filename argument?
        Toast.makeText(GeneratingActivity.this, "Loading not yet implemented.", Toast.LENGTH_SHORT).show();
        Log.v(TAG, "Loading not yet implemented.");

        throw new UnsupportedOperationException("Loading from file is not yet implemented.");
        // simulate
//        delayer.postDelayed(new Runnable() {
//            @Override
//            public void run() {
//                setLoadingCaption("Loading file...");
//                delayer.postDelayed(new Runnable() {
//                    @Override
//                    public void run() {
//                        simulateBuild("loading", 1000, 10);
//                    }
//                }, 500);
//            }
//        }, 500);
    }

    private void build(){
        setLoadingCaption("Generating maze...");
        MazeFactory factory = new MazeFactory();
        factory.order(new Order() {
            @Override
            public int getSkillLevel() {
                return getIntentComplexity();
            }

            @Override
            public Builder getBuilder() {
                String gen = getIntentGenerator();
                if(gen.equalsIgnoreCase("DFS")){
                    return Builder.DFS;
                }
                else if(gen.equalsIgnoreCase("Prim")){
                    return Builder.Prim;
                }
                else if(gen.equalsIgnoreCase("Kruskal")){
                    return Builder.Kruskal;
                }
                else{
                    return Builder.DFS; // default to DFS
                }
            }

            @Override
            public boolean isPerfect() {
                return false;
            }

            @Override
            public void deliver(MazeConfiguration mazeConfig) {
                SingleMazeHolder.maze = mazeConfig;
                done();
            }

            @Override
            public void updateProgress(final int percentage) {
                delayer.post(new Runnable() {
                    @Override
                    public void run() {
                        setLoadingCaption("Building BST... (" + percentage + "%)");
                    }
                });
            }
        });
    }

    /**
     * Runnable updating UI numbers.
     */
    private class SimulatedBuildProgress implements Runnable{
        int progress;
        public SimulatedBuildProgress(int progress){
            this.progress = progress;
        }
        @Override
        public void run() {
            setLoadingCaption("Building BST... (" + this.progress + "%)");
        }
    }

    /**
     * Sets the caption text below the loading icon
     * @param text the text to display
     */
    protected void setLoadingCaption(String text){
        TextView captionBox = (TextView) findViewById(R.id.generating_caption);
        captionBox.setText(text);
    }

    /**
     * Starts the play activity. To be called when generation is complete.
     */
    protected void done(){
        //this.mazeInfo = new PlaceholderMaze(getIntentComplexity(), getIntentGenerator());
        if(cancelDialog != null) {
            cancelDialog.dismiss();
        }
        Intent playIntent = new Intent(this, PlayActivity.class);
        Bundle playInfo = new Bundle();
        // possibly pass info such as driver? could take care of this here when instantiating controller
        playInfo.putString(AMazeActivity.DRIVER, getIntentDriver());
        playIntent.putExtras(playInfo);
        startActivity(playIntent);
        finish();
    }

    /**
     * Gets the preference of whether to load from file if available from the creating Intent.
     * @return true if should attempt load from file; false otherwise.
     */
    protected boolean getIntentLoad(){
        return getIntent().getBooleanExtra(AMazeActivity.LOAD_EXISTING, false);
    }

    /**
     * Gets the maze complexity as set in the creating Intent.
     * @return integer representing the complexity
     */
    protected int getIntentComplexity(){
        return getIntent().getIntExtra(AMazeActivity.COMPLEXITY, 0);
    }

    /**
     * Gets the driver as set in the creating Intent.
     * @return string representing the driver
     */
    protected String getIntentDriver(){
        return getIntent().getStringExtra(AMazeActivity.DRIVER);
    }

    /**
     * Gets the generator as set in the creating Intent.
     * @return string representing the generator
     */
    protected String getIntentGenerator(){
        return getIntent().getStringExtra(AMazeActivity.GENERATOR);
    }

    /**
     * Gets the file name to load as set in the creating Intent.
     * @return string of the file name
     */
    private String getIntentFilename(){
        return getIntent().getStringExtra(AMazeActivity.FILENAME);
    }
}
