package falstad;

import generation.CardinalDirection;
import generation.Distance;
import generation.MazeConfiguration;

/**
 * RobotDriver which attempts to reach the exit by following the distance-to-exit measures
 * stored in the maze configuration.
 * 
 * CRC:
 * Wizard extends BasicRobotDriver (abstract RobotDriver)
 * 
 * Responsibilities:
 * Give instructions to Robot so it reaches the exit
 * 
 * Collaborators:
 * See abstract superclass
 * 
 * @author Ben Zhang
 *
 */
public class Wizard extends BasicRobotDriver {
	
	protected MazeConfiguration mazeConfig;
	
	@Override
	public void setupUsingMaze(MazeController controller){
		mazeConfig = controller.getMazeConfiguration();
	}

	@Override
	protected boolean driveStep() throws Exception {
		int[] robotPos = robot.getCurrentPosition();
		int[] closer = mazeConfig.getNeighborCloserToExit(robotPos[0], robotPos[1]);
		turnToFace( CardinalDirection.East.getDirection(closer[0] - robotPos[0], closer[1] - robotPos[1]) );
		registeredMove(1);
		return true;
	}
	
//	@Override
//	public boolean drive2Exit() throws Exception {
//		while(!robot.isAtGoal()){
//			float initialEnergy = robot.getBatteryLevel();
//			
//			if(robot.hasStopped()){
//				throw new Exception("Wizard was stopped before it could reach exit.");
//				//return false; // throw an exception?
//			}
//			System.out.println("Robot is at " + robot.getCurrentPosition()[0] + "," + robot.getCurrentPosition()[1] + " facing " + robot.getCurrentDirection());
//			int[] robotPos = robot.getCurrentPosition();
//			int[] closer = mazeConfig.getNeighborCloserToExit(robotPos[0], robotPos[1]);
//			turnToFace( CardinalDirection.East.getDirection(closer[0] - robotPos[0], closer[1] - robotPos[1]) );
//			registeredMove(1);
//			
//			float endEnergy = robot.getBatteryLevel();
//			registerEnergyUsed(initialEnergy - endEnergy);
//			
//			
//			if(robotInPreviousState()){
//				System.out.println("Previous state list is len " + positionHistory.size());
//				System.err.println("WallFollower looped back to position it was in before; cannot solve maze.");
//				return false;
//			}
//			else{
//				registerRobotReached();
//			}
//		}
//		return true;
//	}
}
