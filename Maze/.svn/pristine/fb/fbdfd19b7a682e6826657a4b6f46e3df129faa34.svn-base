package falstad;

import static org.junit.Assert.*;

import java.awt.Point;

import org.junit.Before;
import org.junit.Test;

import generation.CardinalDirection;

public class BasicRobotTest extends BasicRobot{

	@Before
	public void setUp(){
		reset();
		setMaze( new MazeController("test/data/input.xml") );
		getMaze().init();
	}
	
	/**
	 * Tests that getCurrentPosition and getCurrentPoint of BasicRobot work correctly.
	 * 
	 * Used independently, tests correctness in the initial position.
	 * Can also be used to verify correct position values after motion.
	 */
	@Test
	public final void testGetPosition(){
		int[] correctPos = getMaze().getCurrentPosition();
		Point correctPoint = new Point(correctPos[0], correctPos[1]);
		int[] current = null;
		try{
			current = getCurrentPosition();
		}
		catch(Exception e){
			assertTrue("Exception occurred on getting position " + correctPoint.x + "," + correctPoint.y, false);
		}
		assertArrayEquals("Position (arrays) should be the same as maze controller", correctPos, current);
		assertEquals("Position (points) should be the same as maze controller", correctPoint, getCurrentPoint());
	}
	
	/**
	 * Tests that getCurrentDirection of BasicRobot works correctly.
	 * 
	 * Used independently, tests correctness in the initial position.
	 * Can also be used to verify correct direction values after motion.
	 */
	@Test
	public final void testGetDirection(){
		assertEquals("Direction should reflect direction faced in MazeController", getCurrentDirection(), getMaze().getCurrentDirection() );
	}
	
	/**
	 * Tests that move correctly navigates the maze.
	 * Also may expose issues with getCurrentPosition.
	 * On the input.xml maze, the robot starts in a long hallway with space to move forwards.
	 */
	@Test
	public final void testMove (){
		getMaze().getMazeConfiguration().getMazedists().prettyPrint();
		int[] startPos = getMaze().getMazeConfiguration().getStartingPosition();
		Point startPoint = new Point( startPos[0], startPos[1] );
		assertEquals("Starts in position", getCurrentPoint(), startPoint);
		assertEquals("Starts facing to the east", getCurrentDirection(), CardinalDirection.East);
		
		// Test that moving 0 does nothing
		move(0, false);
		assertEquals("Still in start", getCurrentPoint(), startPoint);
		
		// Test moving 1 forwards
		move(1, false);
		Point followPos = new Point(startPoint);
		int[] followDir = null;
		followDir = CardinalDirection.East.getDirection();
		followPos.translate( followDir[0], followDir[1] );
		assertEquals("Now shifted position", getCurrentPoint(), followPos);
		assertEquals("Facing same way", getCurrentDirection(), CardinalDirection.East);
		
		// Test moving far forwards, should hit wall
		int actualDistance = 10;
		int attemptDistance = 100;
		move(attemptDistance, false);
		followPos.translate(actualDistance * followDir[0], actualDistance * followDir[1]);
		assertEquals("Should have reached", getCurrentPoint(), followPos);
	}

	
	@Test
	public final void testDistanceToObstacle(){
		
	}
	
	@Test
	public final void testWorldDirectionOf(){
		
	}
	
}
