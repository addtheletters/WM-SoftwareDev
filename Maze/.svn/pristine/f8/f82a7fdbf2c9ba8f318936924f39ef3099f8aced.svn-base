package generation;

import java.awt.Point;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class MazeBuilderKruskal extends MazeBuilder {

	public MazeBuilderKruskal() {
		this(false);
	}

	public MazeBuilderKruskal(boolean deterministic) {
		super(deterministic);
		System.out.println("MazeBuilderKruskal uses Kruskal's algorithm to generate the maze.");
	}	
	
	
	// types all subject to change below

	@Override
	protected void generatePathways(){
//		int[] start = { random.nextIntWithinInterval(0, width-1),
//						random.nextIntWithinInterval(0, height-1)};
//		HashSet<HashSet<Point>> forest = new HashSet<HashSet<Point>>();
//		HashMap<Point, Integer> 
//		while(forest.size() > 1){
//			
//		}
		
		// Create a forest set of all points as size-1 trees
		HashMap<Point, Integer> forest = new HashMap<Point, Integer>();
		for(int i = 0; i < width; i++){
			for(int j = 0; j < height; j++){
				forest.put( new Point(i,j), height * i + j );
			}
		}
		
		// While there exist more than one trees
				// Pick a random tree
				// Find all neighboring trees
				// Pick a neighboring tree and join it in
					// This join means destroying a wall
		
		while(forest.keySet().size() > 1){
			// grab a random tree from the ones in existence
			Point[] forestPoints = (Point[])forest.keySet().toArray();
			Point examined = forestPoints[ random.nextIntWithinInterval(0, forestPoints.length-1) ];
			
			Set<Wall> destroyableWalls = findSetDestroyableWalls(forest.get(examined), forest);
			// or move destoyableWalls outside the loop, and do addAll(findSetDestroyableWalls()); // like how Prim does it
			if(destroyableWalls.size() > 0){
				// TODO pick one wall and destroy it
				// then do the union to merge the 'trees'
				
			}	
		}
	}
	
	/**
	 * Finds all maze cells which are neighbors of the given tree of cells
	 * @param 
	 * @return
	 */
	protected Set<Wall> findSetDestroyableWalls( int tree, HashMap<Point, Integer> forest ){
		Set<Wall> neighborWalls = new HashSet<Wall>();
		
		for(Point p : forest.keySet()){ 
			if(forest.get(p) == tree){ // for all points in the tree
				neighborWalls.addAll( findCellValidWalls(p, tree, forest) );
			}
		}
		
		return neighborWalls;
	}
	
	/**
	 * Returns list of valid neighbor walls of the cell which are not in the same tree
	 * @param cell
	 * @param tree
	 * @return
	 */
	protected List<Wall> findCellValidWalls( Point cell, int tree, HashMap<Point, Integer> forest ){
		List<Wall> neighbors = new ArrayList<Wall>();
		addNeighborIfValid( neighbors, cell, CardinalDirection.North, tree, forest );
		addNeighborIfValid( neighbors, cell, CardinalDirection.South, tree, forest );
		addNeighborIfValid( neighbors, cell, CardinalDirection.East, tree, forest );
		addNeighborIfValid( neighbors, cell, CardinalDirection.West, tree, forest );
		return neighbors;
	}
	
	protected void addNeighborIfValid( Collection<Wall> group, Point cell, CardinalDirection dir, int tree, HashMap<Point, Integer> forest ){
		Point neighbor = new Point(cell.x + dir.getDirection()[0] , cell.y + dir.getDirection()[1]);
		if( !pointInCellGrid(neighbor) ){
			System.out.println("'Neighbor' is not in grid: " + neighbor.x + "," + neighbor.y);
			return;
		}
		if( forest.get(neighbor) != tree ){
			group.add( new Wall(cell.x, cell.y, dir) );
		}
		else{
			System.out.println("Neighbor is in same tree already.");
		}
	}
	
	protected boolean pointInCellGrid( Point p ){
		return (p.x > 0) && (p.y > 0) && (p.x < width) && (p.y < height);
	}
	
}
