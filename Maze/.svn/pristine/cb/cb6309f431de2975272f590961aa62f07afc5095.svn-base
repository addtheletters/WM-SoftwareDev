package generation;

import static org.junit.Assert.*;

import java.awt.Point;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import org.junit.Before;
import org.junit.Test;

import falstad.Constants;
import generation.Order.Builder;

/**
 * Provides tests for functions within {@link MazeBuilderKruskal}.
 * Also uses general maze-builder testing methods in {@link MazeFactoryTest} to verify that MazeBuilderKruskal functions correctly
 * and that a MazeFactory works properly with it. Each test verifies that the mazes generated by the Kruskal algorithm is a valid maze.
 * 
 * @author Ben Zhang
 *
 */
public class MazeBuilderKruskalTest extends MazeBuilderKruskal {
	/**
	 * Internal factory testing object whose assertions are used to verify correctness of Kruskal.
	 * Testing for Kruskal builder relies upon setup and methods of MazeFactoryTest.
	 */
	private MazeFactoryTest mft;
	
	/**
	 * Initialize the internal factory testing object and prepare to run a test.
	 */
	@Before
	public void setUp(){
		// Internal configuration for specific function testing
		TestOrder order = MazeFactoryTest.constructTestOrder(Builder.Kruskal, true); // skill level determined by constant in MazeFactoryTest
		buildOrder(order);
		cells.initialize();
		
		// MazeFactoryTest for general algorithm testing
		mft = new MazeFactoryTest();
		mft.setUp();
	}
	
	/**
	 * Tests that {@link MazeBuilderKruskal#pointInCellGrid(java.awt.Point)} evaluates points correctly.
	 */
	@Test
	public final void testPointInCellGrid(){
		Point[] testValidPoints = new Point[]{
				new Point(0, 0),
				new Point(1, 1),
				new Point(width - 1, 0),
				new Point(0, height - 1),
				new Point(width - 1, height - 1)
		};
		for( Point p : testValidPoints ){
			assertTrue( "Point " + p.x + "," + p.y + " should be within the grid.", pointInCellGrid(p) );
		}
		Point[] testInvalidPoints = new Point[]{
				new Point(-1, 0),
				new Point(0, -1),
				new Point(width, 0),
				new Point(0, height),
				new Point(width, height),
				new Point(width + 1, height - 1)
		};
		for( Point p : testInvalidPoints ){
			assertFalse( "Point " + p.x + "," + p.y + " should not be within the grid.", pointInCellGrid(p) );
		}
	}
	
	/**
	 * Tests that {@link MazeBuilderKruskal#addNeighborIfValid(java.util.Collection, Point, CardinalDirection, HashMap)} correctly adds valid walls and ignores invalid walls.
	 */
	@Test
	public final void testAddNeighborIfValid(){
		List<Wall> walls = new ArrayList<Wall>();
		HashMap<Point, Integer> forest = createInitialForest();
		Point northWestCorner = new Point(0, 0);
		Point southEastCorner = new Point(width - 1, height - 1);
		Point middle = new Point(width / 2, height / 2);
		for( CardinalDirection cd : CardinalDirection.values() ){
			addNeighborIfValid(walls, northWestCorner, cd, forest );
			addNeighborIfValid(walls, southEastCorner, cd, forest );
			addNeighborIfValid(walls, middle, cd, forest );
		}
		
		Wall[] failedWalls = new Wall[]{
			new Wall(northWestCorner.x, northWestCorner.y, CardinalDirection.North),
			new Wall(northWestCorner.x, northWestCorner.y, CardinalDirection.West),
			new Wall(southEastCorner.x, southEastCorner.y, CardinalDirection.South),
			new Wall(southEastCorner.x, southEastCorner.y, CardinalDirection.East),
		};
		
		Wall[] possibleWalls = new Wall[]{
			new Wall(northWestCorner.x, northWestCorner.y, CardinalDirection.South),
			new Wall(northWestCorner.x, northWestCorner.y, CardinalDirection.East),
			new Wall(southEastCorner.x, southEastCorner.y, CardinalDirection.North),
			new Wall(southEastCorner.x, southEastCorner.y, CardinalDirection.West),
		};
		
		for( Wall w : failedWalls ){
			assertFalse( "Cannot have wall into border " + w, walls.contains( w ) );
		}
		for( Wall w : possibleWalls ){
			assertTrue( "Can have wall " + w, walls.contains(w) );
		}
		for( CardinalDirection cd : CardinalDirection.values() ){
			assertTrue("Can have wall around middle ", walls.contains(new Wall(middle.x, middle.y, cd)));
		}
	}
	
	/**
	 * Test that a factory using the Kruskal builder correctly handles an order while busy using {@link MazeFactoryTest#testOrderWhileBusy(Builder)}.
	 */
	@Test
	public final void testOrderWhileBusyKruskal(){
		mft.testOrderWhileBusy(Builder.Kruskal);
	}
	
	/**
	 * Test that a factory using the Kruskal builder correctly generates both perfect (no rooms) and imperfect (with rooms) mazes.
	 * Uses {@link MazeFactoryTest#placeOrderAndWait(Builder, boolean)}.
	 */
	@Test
	public final void testPerfectImperfectKruskal(){
		mft.placeOrderAndWait(Builder.Kruskal, false);
		mft.placeOrderAndWait(Builder.Kruskal, true);
	}
	
	/**
	 * Test that a factory using the Kruskal builder correctly handles cancellation using {@link MazeFactoryTest#testSmoothCancel(Builder)}.
	 */
	@Test
	public final void testSmoothCancelKruskal(){
		mft.testSmoothCancel(Builder.Kruskal);
	}
	
	/**
	 * Test that a deterministic factory using the Kruskal builder can correctly, consistently generate the same maze using {@link MazeFactoryTest#testDeterministic(Builder)}.
	 */
	@Test
	public final void testDeterministicKruskal(){
		mft.testDeterministic(Builder.Kruskal);
	}
	
	/**
	 * Test that a non-deterministic factory using the Kruskal builder generates inconsistent mazes between runs using {@link MazeFactoryTest#testNonDeterministic(Builder)}.
	 */
	@Test
	public final void testNonDeterministicKruskal(){
		mft.testNonDeterministic(Builder.Kruskal);
	}
	
}
