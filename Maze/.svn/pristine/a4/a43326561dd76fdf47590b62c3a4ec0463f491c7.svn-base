package generation;

import static org.junit.Assert.*;

import org.junit.Before;
import org.junit.Test;

import generation.Order.Builder;

/**
 * This class contains JUnit tests which verify that a maze Builder produces valid mazes when used with a MazeFactory.
 * Tests check that deterministic factories are consistent and nondeterministic ones are inconsistent.
 * 
 * Specifically, this class runs tests on the default maze generator, Builder.DFS, but it could easily be adapted to test others.
 * 
 * @author Ben Zhang
 *
 */
public class MazeFactoryTest {
	private static final int ORDER_SKILL = 3;
	private MazeFactory deterministicFactory;
	private MazeFactory randomFactory;
	
	@Before
	public void setUp(){
		deterministicFactory = new MazeFactory(true);
		randomFactory = new MazeFactory();	
	}
	
	/**
	 * Constructs a TestOrder object using static constants and the parameters given
	 * @param builder The builder the order will specify
	 * @param perfect true to specify a perfect (no holes or extra rooms) order, false otherwise.
	 * @return A TestOrder object holding the specified values
	 */
	public static TestOrder constructTestOrder(Builder builder, boolean perfect){
		return new TestOrder(ORDER_SKILL, builder, perfect);
	}
	
	/**
	 * Checks if all tiles in the maze configuration have been labeled with a valid distance from the exit.
	 * @param mazeConfig configuration of the maze
	 * @return true if all tiles have a valid distance; false otherwise
	 */
	private static boolean allDistancesExist(MazeConfiguration mazeConfig){
		int oneCount = 0;
		int[][] allDists = mazeConfig.getMazedists().getDists();
		for(int i = 0; i < allDists.length; i++){
			for(int j = 0; j < allDists[0].length; j++){
				if( allDists[i][j] == 1 ){
					oneCount += 1;
				}
				if( allDists[i][j] <= 0){
					return false;
				}
			}
		}
		return oneCount == 1;
	}
	
	/**
	 * Debug function which displays the distances to the exit of all maze cells in a neat grid.
	 * @param mazeConfig configuration of the maze
	 */
	public static void prettyPrintDistances(MazeConfiguration mazeConfig){
		int[][] allDists = mazeConfig.getMazedists().getDists();
		for(int i = 0; i < allDists.length; i++){
			for(int j = 0; j < allDists[0].length; j++){
				System.out.print(allDists[i][j] + "\t");
			}
			System.out.print("\n");
		}
	}
	
	/**
	 * Checks if a solution for a maze is specified from the provided position by following
	 * {@link MazeConfiguration#getNeighborCloserToExit(int, int)}
	 * @param mazeConfig configuration of the maze
	 * @param position array of length 2 holding the (x,y) of the start position
	 * @return true if the solution can be verified; false if it fails
	 */
	public static boolean isSolveableFrom(MazeConfiguration mazeConfig, int[] start){
		int[] position = { start[0], start[1] }; // position follows where we are as we try to move from start to the exit
		int distance = mazeConfig.getDistanceToExit(position[0], position[1]);
		while(distance > 1){
//			System.out.println("distance is " + distance);
//			System.out.println("position is " + position[0] + "," + position[1]);
			if(mazeConfig.getMazecells().isExitPosition(position[0], position[1])){
				System.err.println("should not have reached exit yet! investigate?");
				return true;
			}
			int[] closerNeighbor = mazeConfig.getNeighborCloserToExit(position[0], position[1]);
			position[0] = closerNeighbor[0];
			position[1] = closerNeighbor[1];
			int redistance = mazeConfig.getDistanceToExit(position[0], position[1]);
//			if((redistance - distance ) != -1){
//				System.out.println("Distance difference was " + (redistance-distance));
//			}
			//distance--;
			distance = redistance; // update our distance to the exit
		}
		//System.out.println("reached the end");
		return mazeConfig.getMazecells().isExitPosition(position[0], position[1]);
	}
	
	/**
	 * Asserts that a solution for a maze exists from every position within the maze
	 * @param mazeConfig configuration of the maze
	 */
	public static void checkSolveableFromEverywhere(MazeConfiguration mazeConfig){
		for(int i = 0; i < mazeConfig.getWidth(); i++){
			for(int j = 0; j < mazeConfig.getHeight(); j++){
				assertTrue("Maze should be solveable from " + i + "," + j, isSolveableFrom(mazeConfig, new int[]{i, j}));
			}	
		}
	}
	
	/**
	 * Asserts that a the maze is properly constructed with only a single exit
	 * @param mazeConfig configuration of the maze
	 */
	public static void checkSingleExit(MazeConfiguration mazeConfig){
		int exits = 0;
		for(int i = 0; i < mazeConfig.getWidth(); i++){
			for(int j = 0; j < mazeConfig.getHeight(); j++){
				if(mazeConfig.getMazecells().isExitPosition(i, j))
					exits ++;
			}
		}
		assertTrue("Only a single exit should exist (" + exits + ")", exits == 1);
	}
	
	/**
	 * Picks a random position within the maze
	 * @param mazeConfig configuration of the maze
	 * @return int array of length 2 holding (x,y) random position
	 */
	public static int[] randomMazePosition( MazeConfiguration mazeConfig ){
		int[] pos = { 	(int)(Math.random() * mazeConfig.getWidth()),
						(int)(Math.random() * mazeConfig.getHeight()) };
		return pos;
	}
	
	/**
	 * Attempts several assertions to check that the maze configuration is valid.
	 * Checks that all maze tiles have been set with a distance to the exit.
	 * Checks that the maze is solvable from a everywhere within.
	 * Checks that there is only a single exit.
	 * @param mazeConfig configuration of the maze
	 */
	public static void checkMazeValid(MazeConfiguration mazeConfig){
		prettyPrintDistances(mazeConfig);
		assertTrue("All Maze cells should have valid distances to exit", allDistancesExist(mazeConfig));
		//assertTrue("Maze should be solvable from designed start", isSolveableFrom(mazeConfig, mazeConfig.getStartingPosition()));
		//assertTrue("Maze should be solvable from random position", isSolveableFrom(mazeConfig, randomMazePosition(mazeConfig)));
		checkSolveableFromEverywhere(mazeConfig);
		checkSingleExit(mazeConfig);
	}
	
	/**
	 * Creates an order using the provided builder and perfection setting and starts the factory working on it.
	 * @param builder The maze builder to use
	 * @param perfect true for a perfect maze; false otherwise
	 * @param factory The factory with which to place the order
	 * @return the order that was placed
	 */
	public static final TestOrder placeOrder(Builder builder, boolean perfect, MazeFactory factory){
		TestOrder order = constructTestOrder(builder, perfect);
		boolean success = factory.order(order);
		assertTrue("Order should succeed", success);
		return order;
	}
	
	/**
	 * Create an order, starts the factory working on it, waits for completion, and then validates the result.
	 * @param builder The maze builder to use
	 * @param perfect true for a perfect maze; false otherwise
	 * @param factory The factory with which to place the order
	 * @return the order that was placed, should be completed when returned
	 */
	public static final TestOrder placeOrderAndWait(Builder builder, boolean perfect, MazeFactory factory){
		TestOrder order = placeOrder(builder, perfect, factory);
		factory.waitTillDelivered();
		assertTrue("Order should be delivered", order.isDelivered());
		checkMazeValid(order.getResult());
		return order;
	}
	
	/**
	 * Shortcut default to deterministic factory for {@link MazeFactoryTest#placeOrder(Builder, boolean, MazeFactory)}
	 * @param builder The maze builder to use
	 * @param perfect true for a perfect maze; false otherwise
	 * @return the order that was placed
	 */
	public final TestOrder placeOrder(Builder builder, boolean perfect){
		return placeOrder(builder, perfect, deterministicFactory);
	}
	
	/**
	 * Shortcut default to deterministic factory for {@link MazeFactoryTest#placeOrderAndWait(Builder, boolean, MazeFactory)}
	 * @param builder The maze builder to use
	 * @param perfect true for a perfect maze; false otherwise
	 * @return the order that was placed, should be completed when returned
	 */
	public final TestOrder placeOrderAndWait(Builder builder, boolean perfect){
		return placeOrderAndWait(builder, perfect, deterministicFactory);
	}
	
	/**
	 * Test that a builder correctly ignores a second order while busy
	 * @param builder the builder to test
	 */
	public final void testOrderWhileBusy(Builder builder) {
		TestOrder firstOrder = placeOrder(builder, false);
		TestOrder orderWhileBusy = constructTestOrder(builder, false);
		boolean busySuccess = deterministicFactory.order(orderWhileBusy);
		assertFalse("Order should fail", busySuccess);
		deterministicFactory.waitTillDelivered();
		
		assertTrue("First order should be delivered", firstOrder.isDelivered());
		assertFalse("Second order should not be delivered", orderWhileBusy.isDelivered());
		checkMazeValid(firstOrder.getResult());
	}
	
	/**
	 * Test that a builder can fulfill an order correctly after one has been cancelled
	 * @param builder the builder to test
	 */
	public final void testSmoothCancel(Builder builder){
		deterministicFactory.cancel(); // attempt to cancel without having placed an order; should result in no action
		TestOrder interrupted = placeOrder(builder, false);
		deterministicFactory.cancel();
		deterministicFactory.waitTillDelivered(); // should not need to wait at all since order is cancelled
		assertFalse("Order should not be delivered", interrupted.isDelivered());
		placeOrderAndWait(builder, false);
	}
	
	/** 
	 * Test that a builder generates mazes consistently when in a deterministic factory
	 * @param builder the builder to test
	 */
	public final void testDeterministic(Builder builder){
		TestOrder firstOrder = placeOrderAndWait(builder, false);
		TestOrder secondOrder = placeOrderAndWait(builder, false);
		assertEquals("Order results should be identical", firstOrder.getResult().getMazecells(), secondOrder.getResult().getMazecells());
	}
	
	/**
	 * Test to make sure random factory indeed produces inconsistent results.
	 * It is possible but extremely unlikely that this will fail even if a random factory is being used.
	 * @param builder the builder to test
	 */
	public final void testNonDeterministic(Builder builder){
		TestOrder firstOrder = placeOrderAndWait(builder, false, randomFactory);
		TestOrder secondOrder = placeOrderAndWait(builder, false, randomFactory);
		assertNotEquals("Order results should not be identical", firstOrder.getResult().getMazecells(), secondOrder.getResult().getMazecells());
	}
	
	/**
	 * Simple test to check that DFS creates a successful maze for both a 'perfect' (no rooms) and 'imperfect' (rooms) specification
	 */
	@Test
	public final void testPerfectImperfectDFS(){
		placeOrderAndWait(Builder.DFS, true);
		placeOrderAndWait(Builder.DFS, false);
	}
	
	/**
	 * Test that DFS builder correctly ignores an order while busy using {@link MazeFactoryTest#testOrderWhileBusy(Builder)}
	 */
	@Test
	public final void testOrderWhileBusyDFS(){
		testOrderWhileBusy(Builder.DFS);
	}
	
	/**
	 * Test that DFS can fulfill an order correctly after one has been cancelled using {@link MazeFactoryTest#testSmoothCancel(Builder)}
	 */
	@Test
	public final void testSmoothCancelDFS(){
		testSmoothCancel(Builder.DFS);
	}
	
	/** 
	 * Test that DFS generates mazes consistently when used in a deterministic factory using {@link MazeFactoryTest#testDeterministic(Builder)}
	 */
	@Test
	public final void testDeterministicDFS(){
		testDeterministic(Builder.DFS);
	}
	
	/**
	 * Test that DFS with non-deterministic factory generates inconsistent mazes using {@link MazeFactoryTest#testNonDeterministic(Builder)}
	 */
	@Test
	public final void testNonDeterministicDFS(){
		testNonDeterministic(Builder.DFS);
	}
}
