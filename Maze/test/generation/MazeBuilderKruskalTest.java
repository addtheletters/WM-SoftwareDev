package generation;

import static org.junit.Assert.*;

import java.awt.Point;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import org.junit.Before;
import org.junit.Test;

import generation.Order.Builder;

/**
 * Provides tests for functions within {@link MazeBuilderKruskal}.
 * Also uses general maze-builder testing methods in {@link MazeFactoryTest} to verify that MazeBuilderKruskal functions correctly
 * and that a MazeFactory works properly with it. Each test verifies that the mazes generated by the Kruskal algorithm is a valid maze.
 * 
 * @author Ben Zhang
 *
 */
public class MazeBuilderKruskalTest extends MazeBuilderKruskal {
	/**
	 * Internal factory testing object whose assertions are used to verify correctness of Kruskal.
	 * Testing for Kruskal builder relies upon setup and methods of MazeFactoryTest.
	 */
	private MazeFactoryTest mft;
	
	/**
	 * Initialize the internal factory testing object and prepare to run a test.
	 */
	@Before
	public void setUp(){
		// Internal configuration for specific function testing
		TestOrder order = MazeFactoryTest.constructTestOrder(Builder.Kruskal, true); // skill level determined by constant in MazeFactoryTest
		buildOrder(order);
		cells.initialize();
		
		// MazeFactoryTest for general algorithm testing
		mft = new MazeFactoryTest();
		mft.setUp();
	}
	
	/**
	 * Test that {@link MazeBuilderKruskal#pointInCellGrid(java.awt.Point)} evaluates points correctly.
	 */
	@Test
	public final void testPointInCellGrid(){
		Point[] testValidPoints = new Point[]{
				new Point(0, 0),
				new Point(1, 1),
				new Point(width - 1, 0),
				new Point(0, height - 1),
				new Point(width - 1, height - 1)
		};
		for( Point p : testValidPoints ){
			assertTrue( "Point " + p.x + "," + p.y + " should be within the grid.", pointInCellGrid(p) );
		}
		Point[] testInvalidPoints = new Point[]{
				new Point(-1, 0),
				new Point(0, -1),
				new Point(width, 0),
				new Point(0, height),
				new Point(width, height),
				new Point(width + 1, height - 1)
		};
		for( Point p : testInvalidPoints ){
			assertFalse( "Point " + p.x + "," + p.y + " should not be within the grid.", pointInCellGrid(p) );
		}
	}
	
	/**
	 * Test that {@link MazeBuilderKruskal#addNeighborIfValid(java.util.Collection, Point, CardinalDirection, HashMap)} correctly adds valid walls and ignores invalid walls.
	 */
	@Test
	public final void testAddNeighborIfValid(){
		List<Wall> walls = new ArrayList<Wall>();
		HashMap<Point, Integer> forest = createInitialForest();
		Point northWestCorner = new Point(0, 0);
		Point southEastCorner = new Point(width - 1, height - 1);
		Point middle = new Point(width / 2, height / 2);
		// Attempt to add points on all sides of each of these.
		for( CardinalDirection cd : CardinalDirection.values() ){
			addNeighborIfValid(walls, northWestCorner, cd, forest );
			addNeighborIfValid(walls, southEastCorner, cd, forest );
			addNeighborIfValid(walls, middle, cd, forest );
		}
		
		// These walls should fail to be added on the corners (there's already a border)
		Wall[] failedWalls = new Wall[]{
			new Wall(northWestCorner.x, northWestCorner.y, CardinalDirection.North),
			new Wall(northWestCorner.x, northWestCorner.y, CardinalDirection.West),
			new Wall(southEastCorner.x, southEastCorner.y, CardinalDirection.South),
			new Wall(southEastCorner.x, southEastCorner.y, CardinalDirection.East),
		};
		
		// These walls should succeed on the corners (there is no border)
		Wall[] possibleWalls = new Wall[]{
			new Wall(northWestCorner.x, northWestCorner.y, CardinalDirection.South),
			new Wall(northWestCorner.x, northWestCorner.y, CardinalDirection.East),
			new Wall(southEastCorner.x, southEastCorner.y, CardinalDirection.North),
			new Wall(southEastCorner.x, southEastCorner.y, CardinalDirection.West),
		};
		
		for( Wall w : failedWalls ){
			assertFalse( "Cannot have wall into border " + w, walls.contains(w) );
		}
		for( Wall w : possibleWalls ){
			assertTrue( "Can have wall " + w, walls.contains(w) );
		}
		// All walls should succeed to be added to the middle point (all sides are free)
		for( CardinalDirection cd : CardinalDirection.values() ){
			assertTrue("Can have wall around middle ", walls.contains(new Wall(middle.x, middle.y, cd)));
		}
		
		// Now, two of middle's neighbors are in the same tree, so those walls are no longer valid
		forest.put(new Point(middle.x, middle.y + 1), forest.get(middle));
		forest.put(new Point(middle.x - 1, middle.y), forest.get(middle));
		List<Wall> walls2 = new ArrayList<Wall>();
		for(CardinalDirection cd : CardinalDirection.values()){
			addNeighborIfValid(walls2, middle, cd, forest);
		}
		assertEquals("Only two neighbors should have been valid", walls2.size(), 2);
	}
	
	/**
	 * Test that a forest is correctly initialized with 1 cell per tree by {@link MazeBuilderKruskal#createInitialForest()}.
	 */
	@Test
	public final void testCreateForest(){
		HashMap<Point, Integer> forest = createInitialForest();
		// Check that each 'tree' has only one point assigned to it
		int[] treeCounts = new int[width * height + 1]; // need extra space in array because nothing is at index 0
		for(Point p : forest.keySet()){
			treeCounts[forest.get(p)] = treeCounts[forest.get(p)] + 1;
		}
		// Trees start getting numbered at 1 (tree 0 has no cells in it)
		for(int i = 1; i < treeCounts.length; i++){
			assertTrue( "Should be 1 cell per tree", treeCounts[i] <= 1 );
		}
	}
	
	/** 
	 * Test that {@link MazeBuilderKruskal#joinTree(HashMap, int, int)} can modify the 'forest' to correctly reflect joined sets.
	 */
	@Test
	public final void testJoinTree(){
		HashMap<Point, Integer> forest = createInitialForest();
		joinTree(forest, 1, 2);
		joinTree(forest, 1, 3);
		assertEquals("Should be 3 members in tree 1", countTreeSize(forest, 1), 3); // Tree '1' had one originally, we added 2
		assertEquals("Should be 0 members left in tree 2", countTreeSize(forest, 2), 0); // tree 2 should be gone
		joinTree(forest, 4, 5);
		joinTree(forest, 4, 6);
		assertEquals("Should be 3 members in tree 4", countTreeSize(forest, 4), 3);
		joinTree(forest, 4, 1);
		assertEquals("Should be 6 members in tree 4", countTreeSize(forest, 4), 6);
		assertEquals("Should be 0 members in tree 1", countTreeSize(forest, 1), 0);
	}
	
	/**
	 * Counts the number of cells in a 'tree' as represented by a forest map.
	 * @param forest the map describing the association of cells to trees
	 * @param tree the number representing the tree whose cells are counted
	 * @return the number of cells that belong to the tree
	 */
	private static int countTreeSize(HashMap<Point, Integer> forest, int tree){
		int count = 0;
		for(Point p : forest.keySet()){
			if(forest.get(p) == tree)
				count ++;
		}
		return count;
	}
	
	/**
	 * Test that {@link MazeBuilderKruskal#findTreeDestroyableWalls(int, HashMap)} correctly finds all valid walls to knock down of a tree.
	 */
	@Test
	public final void testFindDestroyableWalls(){
		HashMap<Point, Integer> forest = createInitialForest();
		assertEquals("Corner should have 2 options", findTreeDestroyableWalls(1, forest).size(), 2);
		joinTree(forest, 1, 2); // combine corner with one piece to the side
		assertEquals("Corner plus adjacent side should have 3 options", findTreeDestroyableWalls(1, forest).size(), 3);
		joinTree(forest, 1, 4); // combine corner two cells with one side piece spaced away
		assertEquals("Corner plus adjacent plus distant side should have 6 options", findTreeDestroyableWalls(1, forest).size(), 6);
	}
	
	/**
	 * Test that a factory using the Kruskal builder correctly handles an order while busy using {@link MazeFactoryTest#testOrderWhileBusy(Builder)}.
	 */
	@Test
	public final void testOrderWhileBusyKruskal(){
		mft.testOrderWhileBusy(Builder.Kruskal);
	}
	
	/**
	 * Test that a factory using the Kruskal builder correctly generates both perfect (no rooms) and imperfect (with rooms) mazes.
	 * Uses {@link MazeFactoryTest#placeOrderAndWait(Builder, boolean)}.
	 */
	@Test
	public final void testPerfectImperfectKruskal(){
		mft.placeOrderAndWait(Builder.Kruskal, false);
		mft.placeOrderAndWait(Builder.Kruskal, true);
	}
	
	/**
	 * Test that a factory using the Kruskal builder correctly handles generating varying skill levels of maze.
	 * Uses {@link MazeFactoryTest#testVaryingSkillLevels(Builder, boolean)}.
	 */
	@Test
	public final void testVaryingSkillKruskal(){
		mft.testVaryingSkillLevels(Builder.Kruskal, false);
	}
	
	/**
	 * Test that a factory using the Kruskal builder correctly handles cancellation using {@link MazeFactoryTest#testSmoothCancel(Builder)}.
	 */
	@Test
	public final void testSmoothCancelKruskal(){
		mft.testSmoothCancel(Builder.Kruskal);
	}
	
	/**
	 * Test that a deterministic factory using the Kruskal builder can correctly, consistently generate the same maze using {@link MazeFactoryTest#testDeterministic(Builder)}.
	 */
	@Test
	public final void testDeterministicKruskal(){
		mft.testDeterministic(Builder.Kruskal);
	}
	
	/**
	 * Test that a non-deterministic factory using the Kruskal builder generates inconsistent mazes between runs using {@link MazeFactoryTest#testNonDeterministic(Builder)}.
	 */
	@Test
	public final void testNonDeterministicKruskal(){
		mft.testNonDeterministic(Builder.Kruskal);
	}
	
}
